
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================
`define ss_0 8'b11000000
`define ss_1 8'b11111001
`define ss_2 8'b10100100
`define ss_3 8'b10110000
`define ss_4 8'b10011001
`define ss_5 8'b10010010
`define ss_6 8'b10000010
`define ss_7 8'b11111000
`define ss_8 8'b10000000
`define ss_9 8'b10010000
`define ss_a 8'b10001000
`define ss_b 8'b10000011
`define ss_c 8'b11000110
`define ss_d 8'b10100001
`define ss_e 8'b10000110
`define ss_f 8'b10001110

module lab5_FPGA(

	//////////// CLOCK //////////
	input 		          		ADC_CLK_10,
	input 		          		MAX10_CLK1_50,
	input 		          		MAX10_CLK2_50,

	//////////// SEG7 //////////
	output		     reg [7:0]		HEX0,
	output		     reg [7:0]		HEX1,
	output		     reg [7:0]		HEX2,
	output		     reg [7:0]		HEX3,
	output		     reg [7:0]		HEX4,
	output		     reg [7:0]		HEX5,

	//////////// KEY //////////
	input 		     [1:0]		KEY,

	//////////// LED //////////
	output		     reg [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW
);



//=======================================================
//  REG/WIRE declarations
//=======================================================
   reg out0,out1,out2,out3,out4,out5,out6,out7,out8,out9,
	     out10,out11,out12,out13,out14,out15,out16,out17,out18,out19;
	reg reset;
	reg go;
	wire [3:0] clkout; 
   wire clk;
	wire [7:0]countout;
	reg out_reset1;
	reg out_reset2;
	reg [19:0] count,count_c;
	reg [23:0] countt,countt_c;
	wire en_freq4;
	reg [7:0] ssg1;
	reg [7:0] ssg2;
	reg [3:0]cnt;
	reg out_c;
	wire clk_in;
	reg en_increment;
   reg [3:0] cntout1;
	reg [3:0] cntout2;


//=======================================================
//  Structural coding
//=======================================================
//assign clk = MAX10_CLK1_50;

always @(*) begin
// defaults
    count_c = count + 20'h00001; // a flip-flop register
	 countt_c = countt + 20'h00001; // a flip-flop register
    en_increment = 1'b0; // a combinational logic signal
  if (count == 20'hfffff && SW[1]==1'b1) begin
    count_c = 20'h00000; // wrap counter back to zero
    en_increment = 1'b1; // pulse FF enable signal high
  end
  else if (countt == 24'hffffff && SW[1]==1'b0)begin
    countt_c = 20'h00000; // wrap counter back to zero
    en_increment = 1'b1; // pulse FF enable signal high
  end
end
always @(*)begin
   if ( KEY[0] == 1'b0) out_c = 1'b1;
	else if (KEY[1]==1'b0) out_c = 1'b0;
	else if ( out19 == 1'b1 && SW[9]==0) out_c = 1'b1;
   else if ( out0 == 1'b1 && SW[9]==1) out_c = 1'b1;  
	else out_c = 1'b0;
end
always @(posedge MAX10_CLK1_50) begin
    count <= #1 count_c;
	 countt <= #1 countt_c;
  if(SW[0]==1'b1) begin
      out0 <= #1 1'b0;  	
		out1 <= #1 1'b0;
		out2 <= #1 1'b0;
		out3 <= #1 1'b0;
		out4 <= #1 1'b0;
		out5 <= #1 1'b0;
		out6 <= #1 1'b0;
		out7 <= #1 1'b0;
		out8 <= #1 1'b0;
		out9 <= #1 1'b0;
		out10 <= #1 1'b0;
		out11 <= #1 1'b0;
		out12 <= #1 1'b0;
		out13 <= #1 1'b0;
		out14 <= #1 1'b0;
		out15 <= #1 1'b0;
		out16 <= #1 1'b0;
		out17 <= #1 1'b0;
		out18 <= #1 1'b0;
		out19 <= #1 1'b0;
  end
  else if (en_increment == 1'b1 && SW[9] == 1'b0) begin
      out0 <= #1 out_c;  	
		out1 <= #1 out0;
		out2 <= #1 out1;
		out3 <= #1 out2;
		out4 <= #1 out3;
		out5 <= #1 out4;
		out6 <= #1 out5;
		out7 <= #1 out6;
		out8 <= #1 out7;
		out9 <= #1 out8;
		out10 <= #1 out9;
		out11 <= #1 out10;
		out12 <= #1 out11;
		out13 <= #1 out12;
		out14 <= #1 out13;
		out15 <= #1 out14;
		out16 <= #1 out15;
		out17 <= #1 out16;
		out18 <= #1 out17;
		out19 <= #1 out18;
  end
  else if (en_increment == 1'b1 && SW[9] == 1'b1) begin
      out19 <= #1 out_c;  	
		out18 <= #1 out19;
		out17 <= #1 out18;
		out16 <= #1 out17;
		out15 <= #1 out16;
		out14 <= #1 out15;
		out13 <= #1 out14;
		out12 <= #1 out13;
		out11 <= #1 out12;
		out10 <= #1 out11;
		out9 <= #1 out10;
		out8 <= #1 out9;
		out7 <= #1 out8;
		out6 <= #1 out7;
		out5 <= #1 out6;
		out4 <= #1 out5;
		out3 <= #1 out4;
		out2 <= #1 out3;
		out1 <= #1 out2;
		out0 <= #1 out1;
  end
end
///////
always@(*)begin
////////////////////////
//display it on LEDR and HEX[]
     HEX0[2:1] = 2'b11;
     HEX0[7:4] = 4'b1111;
     HEX1[2:1] = 2'b11;
     HEX1[7:4] = 4'b1111;
     HEX2[2:1] = 2'b11;
     HEX2[7:4] = 4'b1111;
     HEX3[2:1] = 2'b11;
     HEX3[7:6] = 2'b11;
////////////////////////
//LEDR
////////////////////////
   
	  LEDR[0] = out0;
	  LEDR[1] = out1;
	  LEDR[2] = out2;
	  LEDR[3] = out3;
	  LEDR[4] = out4;
	  LEDR[5] = out5;
	  LEDR[6] = out6;
	  LEDR[7] = out7;
	  LEDR[8] = out8;
	  LEDR[9] = out9;

////////////////////////
//initial the HEX
///////////////////////
   //assign HEX0[7:0] =8'b1111_1111;	
	//assign HEX1[7:0] =8'b1111_1111;	
	//assign HEX2[7:0] =8'b1111_1111;	
	//assign HEX3[7:0] =8'b1111_1111;
//////////////////////
//HEX
//////////////////////
   
	  HEX0[0] = ~out10;
	  HEX1[0] = ~out11;
	  HEX2[0] = ~out12;
	  HEX3[0] = ~out13;
	  HEX3[5] = ~out14;
	  HEX3[4] = ~out15;
	  HEX3[3] = ~out16;
	  HEX2[3] = ~out17;
	  HEX1[3] = ~out18;
	  HEX0[3] = ~out19;
end
/////////////////////

/////////////////////	
// calculator
/////////////////////
/*always@(*)begin
    out_reset1 = cntout1[0] & cntout1[1] & cntout1[2] & cntout1[3];
    out_reset2 = cntout2[0] & cntout2[1] & cntout2[2] & cntout2[3];
end*/
always@(posedge MAX10_CLK1_50)begin
 if (en_increment == 1'b1)begin
  if(SW[0] == 1'b1)begin
   cntout1 <= #1 4'b0;
	cntout2 <= #1 4'b0;
  end	
  else if (out15 == 1'b1 && SW[9] == 1'b0)begin
   if (cntout1 < 4'hf)cntout1 <= #1 cntout1+1'b1;
	else begin cntout1 <= #1 4'b0; cntout2 <= #1 cntout2+1'b1;end
  end
  else if (out15 == 1'b1 && SW[9] == 1'b1)begin
   if (cntout1==4'h0)
	  begin 
	   cntout1 <= #1 4'hf;
	   if (cntout2==4'h0) cntout2 <= #1 4'hf;
		else cntout2 <= #1 cntout2-1'b1;
	  end
   else  cntout1 <= #1 cntout1-1'b1; 
  end
 end
end
   
  //FPGA_up_counter uc1(.out(countout[3:0]), .enable(out15), .clk(MAX10_CLK1_50), .reset(SW[0]), .switch(SW[9]));
   //FPGA_up_counter uc2(.out(countout[7:4]), .enable(out_reset1), .clk(MAX10_CLK1_50), .reset(SW[0]), .switch(SW[9]));
/////////////////////
// seg71
/////////////////////
always @(*) begin
   case(cntout1)
	 0: ssg1 = `ss_0 ;
	 1: ssg1 = `ss_1 ;
	 2: ssg1 = `ss_2 ;
	 3: ssg1 = `ss_3 ;
	 4: ssg1 = `ss_4 ;
	 5: ssg1 = `ss_5 ;
	 6: ssg1 = `ss_6 ;
	 7: ssg1 = `ss_7 ;
	 8: ssg1 = `ss_8 ;
	 9: ssg1 = `ss_9 ;
	 10: ssg1 = `ss_a ;
	 11: ssg1 = `ss_b ;
	 12: ssg1 = `ss_c ;
	 13: ssg1 = `ss_d ;
	 14: ssg1 = `ss_e ;
	 15: ssg1 = `ss_f ;
	 default begin ssg1 = `ss_0 ; end
 endcase
 /////////////////////
// seg72
/////////////////////
   case(cntout2)
	 0: ssg2 = `ss_0 ;
	 1: ssg2 = `ss_1 ;
	 2: ssg2 = `ss_2 ;
	 3: ssg2 = `ss_3 ;
	 4: ssg2 = `ss_4 ;
	 5: ssg2 = `ss_5 ;
	 6: ssg2 = `ss_6 ;
	 7: ssg2 = `ss_7 ;
	 8: ssg2 = `ss_8 ;
	 9: ssg2 = `ss_9 ;
	 10: ssg2 = `ss_a ;
	 11: ssg2 = `ss_b ;
	 12: ssg2 = `ss_c ;
	 13: ssg2 = `ss_d ;
	 14: ssg2 = `ss_e ;
	 15: ssg2 = `ss_f ; 
	 default begin ssg2 = `ss_0 ; end
 endcase

end
always@(*)begin
    HEX4 = ssg1;
    HEX5 = ssg2;
end


endmodule

