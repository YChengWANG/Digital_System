
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================
`define ss_0 7'b1000000
`define ss_1 7'b1111001
`define ss_2 7'b0100100
`define ss_3 7'b0110000
`define ss_4 7'b0011001
`define ss_5 7'b0010010
`define ss_6 7'b0000010
`define ss_7 7'b1111000
`define ss_8 7'b0000000
`define ss_9 7'b0010000
`define ss_a 7'b0001000
`define ss_b 7'b0000011
`define ss_c 7'b1000110
`define ss_d 7'b0100001
`define ss_e 7'b0000110
`define ss_f 7'b0001110


module fortest(

	//////////// CLOCK //////////
	input 		          		ADC_CLK_10,
	input 		          		MAX10_CLK1_50,
	input 		          		MAX10_CLK2_50,

	//////////// SEG7 //////////
	output		     reg[7:0]		HEX0,
	output		     reg[7:0]		HEX1,
	output		     reg[7:0]		HEX2,
	output		     reg[7:0]		HEX3,
	output		     reg[7:0]		HEX4,
	output		     reg[7:0]		HEX5,

	//////////// KEY //////////
	input 		     [1:0]		KEY,

	//////////// LED //////////
	output		 reg [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW
);



//=======================================================
//  REG/WIRE declarations
//=======================================================
parameter INITIAL = 2'b0;
parameter COUNTDOWN = 2'h1;
parameter COUNTUP = 2'h2;
parameter WAIT = 2'h3;
parameter PRESSED = 2'h4;

reg [1:0] state, state_c; // declare both FF regs
reg [1:0] statee, statee_c; // declare both FF regs
wire clk;
reg [15:0] count, count_c; // 29 bits counts up to 536 million
reg [15:0] count1, count_c1; // 29 bits counts up to 536 million
reg [23:0] countt, countt_c;
reg en_increment, en_increment1, en_incrementt; // I use a reg in this example
reg [3:0] cntout0,cntout1,cntout2,cntout3,cntout4,cntout5;// counter fot calculating
reg [3:0] cntoutx0,cntoutx1,cntoutx2,cntoutx3,cntoutx4,cntoutx5;// counter fot calculating
reg [3:0] reg_cntout0,reg_cntout1,reg_cntout2,reg_cntout3,reg_cntout4,reg_cntout5;
reg [3:0] cntout00,cntout11,cntout22,cntout33,cntout44,cntout55;
reg [6:0] ssg0,ssg1,ssg2,ssg3,ssg4,ssg5,ssg6;
reg stop,stop1;
reg [13:0] bcd_cnt,bcd_cnt1;
reg [19:0] delay_cnt;
reg [3:0]rank_cnt;
reg [3:0] rank_out;
reg key,go,gogo,select;
reg KEY_reg;
//=======================================================
//  Structural coding
//=======================================================
assign clk = MAX10_CLK1_50;                           // change name of clock
////////////////////////////////////////////////////////////////////////////////////////
always @(posedge clk)begin                        // Combinational logic for state machine
  state_c = state; // defaults (place first)
case (state)                                   // default same state
 INITIAL:begin
     count <= #1 1'b0;
     bcd_cnt <= #1 1'b0;
     count1 <= #1 1'b0;
     bcd_cnt1 <= #1 1'b0;
	  rank_cnt <= #1 1'b0;
	  select = 1'b0;
	  //delay_cnt <= # 10'b0;
	      cntout11 <= #1 4'b0000;
	      cntout22 <= #1 4'b0000;
	      cntout33 <= #1 4'b0000;
	      cntout44 <= #1 4'b0000;
	      cntout55 <= #1 4'b0000;
			cntoutx1 <= #1 4'b0000;
	      cntoutx2 <= #1 4'b0000;
	      cntoutx3 <= #1 4'b0000;
	      cntoutx4 <= #1 4'b0000;
	      cntoutx5 <= #1 4'b0000;
			cntout1 <= #1 4'b0000;
	      cntout2 <= #1 4'b0000;
	      cntout3 <= #1 4'b0000;
	      cntout4 <= #1 4'b0000;
	      cntout5 <= #1 4'b0000;
			reg_cntout1 <= #1 4'b0000;
	      reg_cntout2 <= #1 4'b0000;
	      reg_cntout3 <= #1 4'b0000;
	      reg_cntout4 <= #1 4'b0000;
	      reg_cntout5 <= #1 4'b0000;
			LEDR <= #1 10'b0;
     /*assign*/ HEX0 = 8'b1111_1111;
     /*assign*/ HEX1 = 8'b1111_1111;
     /*assign*/ HEX2 = 8'b1111_1111;
	  /*assign*/ HEX3 = 8'b1111_1111;
     /*assign*/ HEX4 = 8'b1111_1111;
     /*assign*/ HEX5 = 8'b1111_1111;
   if (~KEY[1])begin
	   state_c = COUNTDOWN;
	end
	else state_c = INITIAL;
 end
////////////////////////////////////////////////////////////////////////////////////////
 COUNTDOWN:begin
       en_increment1 = 1'b1;
       //always @(*) begin                                     // My 1000 HZ clock
       //count_c1 = count1 + 16'h0001; // a flip-flop register
       //en_increment1 = 1'b0; // a combinational logic signal
       //if (count1 == 16'd49999) begin
         //count_c1 = 16'h0000; // wrap counter back to zero
         //en_increment1 = 1'b1; // pulse FF enable signal high
       //end
     //end                   //1000 HZ clock end
     //always @(*) begin                                     // My slow clock
       //countt_c = countt + 24'h000001; // a flip-flop register
       //en_incrementt = 1'b0; // a combinational logic signal
       //if (countt == 24'hffffff) begin
         //countt_c = 24'h000000; // wrap counter back to zero
         //en_incrementt = 1'b1; // pulse FF enable signal high
       //end
     //end                     //1000 HZ clock end
     //always @(posedge clk) begin                           // bcd counter 
        if (en_increment1 == 1'b1)begin
          if(SW[0] == 1'b1) bcd_cnt1 <= #1 1'b0;
	       else if (SW[0] == 1'b0)begin 
	          if (bcd_cnt1 < 14'd14999 ) begin
	             bcd_cnt1 <= #1 bcd_cnt1 + 1'b1;
		          stop1 = 1'b0;
	          end
	          else stop1 = 1'b1;
	       end
	     end  
     //end
    //always @(posedge clk) begin                           // count down 3,2,1,0
        count1 <= #1 count_c1;
        /*if (SW[0] == 1'b1)begin
          cntout11 <= #1 4'b0000;
	       cntout22 <= #1 4'b0000;
	       cntout33 <= #1 4'b0000;
	       cntout44 <= #1 4'b0000;
	       cntout55 <= #1 4'b0000;
        end
        else */if (en_increment1 == 1'b1 && bcd_cnt1 < 4000) begin
           if (cntout11 < 9)begin 
	          cntout11 <= #1 cntout11 + 4'b0001;
	        end  
	        else begin cntout11 <= #1 4'b0000;
	             cntout22 <= #1 cntout22 +4'b0001;
	              if (cntout22 < 9)begin 
		              cntout22 <= #1 cntout22 +4'b0001;
		           end
		           else begin cntout22 <= #1 4'b0000;
	                 cntout33 <= #1 cntout33 +4'b0001;
	                 if (cntout33 < 9)begin 
			               cntout33 <= #1 cntout33 +4'b0001;
			           end 
	                 else begin cntout33 <= #1 4'b0000;
	                            cntout44 <= #1 cntout44 +4'b0001; 
			           end
		           end
	        end
        end
     //end	
     //always @(*) begin
        case(cntout44)
	        0: ssg0 = `ss_3 ;
	        1: ssg0 = `ss_2 ;
	        2: ssg0 = `ss_1 ;
	        3: ssg0 = `ss_0 ;
	        default begin ssg0 = `ss_0 ; end
        endcase
     //end 
     /*assign*/ HEX3[6:0] = ssg0;
     /*assign*/ HEX3[7] = 1'b1;
     /*assign*/ HEX0 = 8'b1111_1111;
     /*assign*/ HEX1 = 8'b1111_1111;
     /*assign*/ HEX2 = 8'b1111_1111;
     /*assign*/ HEX4 = 8'b1111_1111;
     /*assign*/ HEX5 = 8'b1111_1111;
     if(cntout44 == 4)begin
       state_c = COUNTUP;
     end
  end
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
 COUNTUP:begin
        en_incrementt = 1'b1;
      //always @(*) begin                                     // My 1000 HZ clock
       //count_c = count + 16'h0001; // a flip-flop register
       //en_increment = 1'b0; // a combinational logic signal
       //if (count == 16'd49999) begin
         //count_c = 16'h0000; // wrap counter back to zero
         en_increment = 1'b1; // pulse FF enable signal high
       //end
     //end                   //1000 HZ clock end
     //always @(*) begin                                     // My slow clock
       //countt_c = countt + 24'h000001; // a flip-flop register
       //en_incrementt = 1'b0; // a combinational logic signal
       //if (countt == 24'd12500000) begin
         //countt_c = 24'h000000; // wrap counter back to zero
         //en_incrementt = 1'b1; // pulse FF enable signal high
       //end
     //end                     //1000 HZ clock end
     //always @(posedge clk) begin                           // bcd counter 
        if (en_increment == 1'b1)begin
          if(~KEY[0]) bcd_cnt <= #1 1'b0;
	       else if (KEY[0])begin 
	          if (bcd_cnt < 14'd14999 ) begin
	             bcd_cnt <= #1 bcd_cnt + 1'b1;
		          stop = 1'b0;
	          end
	          else stop = 1'b1;
	       end
	     end  
     //end
     //always @(posedge clk) begin                           // counter xx.xxx to 14.999
         count <= #1 count_c;
       /*if (SW[0] == 1'b1)begin
         cntout1 <= #1 4'b0000;
	      cntout2 <= #1 4'b0000;
	      cntout3 <= #1 4'b0000;
	      cntout4 <= #1 4'b0000;
	      cntout5 <= #1 4'b0000;
       end
       else */if (en_increment == 1'b1 && stop != 1'b1) begin
          if (cntout1 < 9)begin 
	          cntout1 <= #1 cntout1 + 4'b0001;
	       end  
	       else begin cntout1 <= #1 4'b0000;
	                  cntout2 <= #1 cntout2 +4'b0001;
	          if (cntout2 < 9)begin 
		               cntout2 <= #1 cntout2 +4'b0001;
		       end
		       else begin cntout2 <= #1 4'b0000;
	                     cntout3 <= #1 cntout3 +4'b0001;
	             if (cntout3 < 9)begin 
			               cntout3 <= #1 cntout3 +4'b0001;
			       end 
	             else begin cntout3 <= #1 4'b0000;
	                        cntout4 <= #1 cntout4 +4'b0001;
				 //if (cntout5 == 4'b0000)begin	// when 0, count to 9		 
			          if(cntout4 < 9)begin 
				               cntout4 <= #1 cntout4 +4'b0001;
				       end
				       else begin cntout4 <= #1 4'b0000;
	                           cntout5 <= #1 cntout5 +4'b0001;
	                   if (cntout5 < 9) cntout5 <= #1 cntout5 +4'b0001;
					 // else cntout5 <= #1 4'b0001;
				       end
				 //end
				 //else if (cntout5 == 4'b0001)begin // when 1, count to 4
				  //if(cntout4 < 4)begin 
				          //cntout4 <= #1 cntout4 +4'b0001;
				  //end
				  //else begin cntout4 <= #1 4'b0000;
	                   //   cntout5 <= #1 cntout4 +4'b0001;
	              //if (cntout5 < 1) cntout5 <= #1 cntout5 +4'b0001;
					  //else cntout5 <= #1 4'b0001;
				  //end
				 //end 
			       end  
		       end		  
	       end		  
       end
     //end
	     if (en_increment == 1'b1)begin                     // delay 1 sec
          /*if(KEY[1]) begin 
			    delay_cnt <= #1 1'b0;
				 select = 1'b0;
			  end*/ 
	       //if (~KEY[1])begin 
	          if (delay_cnt < 20'd1000 && go) begin
	             delay_cnt <= #1 delay_cnt + 1'b1;
		          select = 1'b1;
	          end
	          else if(delay_cnt >= 20'd1000) begin
				    delay_cnt <= #1 1'b0;
					 select = 1'b0;
					 go <= #1 1'b0;
				  end	 
	       //end
	     end
		  if (en_increment == 1'b1)begin
		     if(~KEY[1])begin
			     go <=#1 1'b1;
		        cntoutx1 <=#1 cntout1;
			     cntoutx2 <=#1 cntout2;
			     cntoutx3 <=#1 cntout3;
			     cntoutx4 <=#1 cntout4;
			     cntoutx5 <=#1 cntout5; 
		     end
		  end
		 //if (en_increment == 1'b1)begin                    //delay 1 second
          /* if (~KEY[1])begin 
	          if (delay_cnt < 10'd999 ) begin
	             delay_cnt <= #1 delay_cnt + 1'b1;
		          select = 1'b1;
	          end
	          else begin
				    //delay_cnt <= #1 1'b0;
				    select = 1'b0;
				 end
	       end*/
	     //end  
	    if (en_increment == 1'b1)begin                     // register to display the time
          if(stop != 1'b1)begin
			     if(select==1'b1)begin
			       reg_cntout1 <= #1 cntoutx1;
					 reg_cntout2 <= #1 cntoutx2;
					 reg_cntout3 <= #1 cntoutx3;
					 reg_cntout4 <= #1 cntoutx4;
					 reg_cntout5 <= #1 cntoutx5;
				  end 
				  else if(select==1'b0) begin
				  	 reg_cntout1 <= #1 cntout1;
					 reg_cntout2 <= #1 cntout2;
					 reg_cntout3 <= #1 cntout3;
					 reg_cntout4 <= #1 cntout4;
					 reg_cntout5 <= #1 cntout5;
				  end
			  end	
			  else if(stop == 1'b1) begin
			       reg_cntout1 <= #1 cntout1;
					 reg_cntout2 <= #1 cntout2;
					 reg_cntout3 <= #1 cntout3;
					 reg_cntout4 <= #1 cntout4;
					 reg_cntout5 <= #1 cntout5;
			  end 
		 end 
		///////////////////////////////////////////////////////////////////////
	    KEY_reg <= #1 ~KEY[1];	
       gogo = ~KEY[1] & ~KEY_reg;
	    if (gogo)begin                     // GSB counter
          rank_cnt <= #1 rank_cnt + 1;
		 end 
		 if(go)begin
	        if (rank_cnt == 0) rank_out = 4'h0;                // the rank (GSB-)
	        else if (rank_cnt==1) rank_out = 4'h1;                    
		     else if (rank_cnt == 2) rank_out = 4'h2;
		     else if (rank_cnt == 3) rank_out = 4'h3;
		     else rank_out = 4'h4;
		 end
		 else rank_out = 4'h0;
     //always @(*) begin
        case(reg_cntout1)
	      0: ssg1 = `ss_0 ;
	      1: ssg1 = `ss_1 ;
	      2: ssg1 = `ss_2 ;
	      3: ssg1 = `ss_3 ;
	      4: ssg1 = `ss_4 ;
	      5: ssg1 = `ss_5 ;
	      6: ssg1 = `ss_6 ;
	      7: ssg1 = `ss_7 ;
	      8: ssg1 = `ss_8 ;
	      9: ssg1 = `ss_9 ;
	      10: ssg1 = `ss_a ;
	      11: ssg1 = `ss_b ;
	      12: ssg1 = `ss_c ;
	      13: ssg1 = `ss_d ;
	      14: ssg1 = `ss_e ;
	      15: ssg1 = `ss_f ;
	      default begin ssg1 = `ss_0 ; end
         endcase
/////////////////////
// seg72
/////////////////////
        case(reg_cntout2)
	      0: ssg2 = `ss_0 ;
	      1: ssg2 = `ss_1 ;
	      2: ssg2 = `ss_2 ;
	      3: ssg2 = `ss_3 ;
	      4: ssg2 = `ss_4 ;
	      5: ssg2 = `ss_5 ;
	      6: ssg2 = `ss_6 ;
	      7: ssg2 = `ss_7 ;
	      8: ssg2 = `ss_8 ;
	      9: ssg2 = `ss_9 ;
	      10: ssg2 = `ss_a ;
	      11: ssg2 = `ss_b ;
	      12: ssg2 = `ss_c ;
	      13: ssg2 = `ss_d ;
	      14: ssg2 = `ss_e ;
	      15: ssg2 = `ss_f ; 
	      default begin ssg2 = `ss_0 ; end
         endcase
/////////////////////
// seg73
/////////////////////	 
        case(reg_cntout3)
	      0: ssg3 = `ss_0 ;
	      1: ssg3 = `ss_1 ;
	      2: ssg3 = `ss_2 ;
	      3: ssg3 = `ss_3 ;
	      4: ssg3 = `ss_4 ;
	      5: ssg3 = `ss_5 ;
	      6: ssg3 = `ss_6 ;
	      7: ssg3 = `ss_7 ;
	      8: ssg3 = `ss_8 ;
	      9: ssg3 = `ss_9 ;
	      10: ssg3 = `ss_a ;
	      11: ssg3 = `ss_b ;
	      12: ssg3 = `ss_c ;
	      13: ssg3 = `ss_d ;
	      14: ssg3 = `ss_e ;
	      15: ssg3 = `ss_f ;
	      default begin ssg3 = `ss_0 ; end
        endcase
/////////////////////
// seg74
/////////////////////
        case(reg_cntout4)
	      0: ssg4 = `ss_0 ;
	      1: ssg4 = `ss_1 ;
	      2: ssg4 = `ss_2 ;
	      3: ssg4 = `ss_3 ;
	      4: ssg4 = `ss_4 ;
	      5: ssg4 = `ss_5 ;
	      6: ssg4 = `ss_6 ;
	      7: ssg4 = `ss_7 ;
	      8: ssg4 = `ss_8 ;
	      9: ssg4 = `ss_9 ;
	      10: ssg4 = `ss_a ;
	      11: ssg4 = `ss_b ;
	      12: ssg4 = `ss_c ;
	      13: ssg4 = `ss_d ;
	      14: ssg4 = `ss_e ;
	      15: ssg4 = `ss_f ; 
	      default begin ssg4 = `ss_0 ; end
        endcase 
/////////////////////
// seg75
/////////////////////
        case(reg_cntout5)
	      0: ssg5 = 7'b1111111 ;
	      1: ssg5 = `ss_1 ;
	      2: ssg5 = `ss_2 ;
	      3: ssg5 = `ss_3 ;
	      4: ssg5 = `ss_4 ;
	      5: ssg5 = `ss_5 ;
	      6: ssg5 = `ss_6 ;
	      7: ssg5 = `ss_7 ;
	      8: ssg5 = `ss_8 ;
	      9: ssg5 = `ss_9 ;
	      10: ssg5 = `ss_a ;
	      11: ssg5 = `ss_b ;
	      12: ssg5 = `ss_c ;
	      13: ssg5 = `ss_d ;
	      14: ssg5 = `ss_e ;
	      15: ssg5 = `ss_f ; 
	      default begin ssg5 = `ss_0 ; end 
        endcase
		  case(rank_out)
		   0:ssg6 = 8'b1111_1111;
			1:ssg6 = 8'b0000_0010;
			2:ssg6 = 8'b0001_0010;
			3:ssg6 = 8'b0000_0011;
			default ssg6 = 8'b1011_1111;
		  endcase	
     //end
     /*assign*/ HEX0[6:0] = ssg1;
     /*assign*/ HEX0[7] = 1'b1;
     /*assign*/ HEX1[6:0] = ssg2;
     /*assign*/ HEX1[7] = 1'b1;
     /*assign*/ HEX2[6:0] = ssg3;
     /*assign*/ HEX2[7] = 1'b1;
     /*assign*/ HEX3[6:0] = ssg4;
     /*assign*/ HEX3[7] = 1'b0;
     /*assign*/ HEX4[6:0] = ssg5;
     /*assign*/ HEX4[7] = 1'b1;
     /*assign*/ HEX5 = ssg6;
	  /*assign*/ HEX5[7] = 1'b1;
     //always @(posedge clk)begin
       countt <= #1 countt_c;
       if(en_incrementt == 1'b1)begin
        if (stop == 1'b1 && SW[0] == 1'b0)
	       LEDR <= #1 ~LEDR; 
	     else LEDR <= #1 10'b0;
       end
     //end
  end  
////////////////////////////////////////////////////////////////////////////////////////
 default:begin
    state_c = 2'bxx; 
 end  
endcase
// reset logic (place last to override other logic)
if (~KEY[0]) begin
  state_c = INITIAL;
end
end
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
always @(posedge clk) begin                           // Instantiates registers (flip-flops)
   state <= #1 state_c;
end

endmodule
