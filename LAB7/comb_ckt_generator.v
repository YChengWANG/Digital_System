//============================================================================
// comb_ckt_generator.v
//
// This code is generated by Terasic System Builder
// and modified by M. Hildebrand and B. Baas
//
// 2018/02/05 First version
// 2018/04/24 Routed all board-level switches and LEDs to and from this module
//============================================================================

module comb_ckt_generator (
   // VGA-related signals
   col,
   row,
   red,
   green,
   blue,
   // input push buttons and switches
   KEY,
   SW,
   // output LEDs and 7-segment displays
   LEDR,
   HEX0,
   HEX1,
   HEX2,
   HEX3,
   HEX4,
   HEX5.
	MAX10_CLK1_50
   );

input  [9:0]  col;
input  [8:0]  row;
input         MAX10_CLK1_50;
output [3:0]  red;    // 4-bit color output
output [3:0]  green;  // 4-bit color output
output [3:0]  blue;   // 4-bit color output

// input push buttons and switches
input  [1:0]  KEY;    // two board-level push buttons KEY1 - KEY0
input  [9:0]  SW;     // ten board-level switches SW9 - SW0

// output LEDs and 7-segment displays
output [9:0]  LEDR;   // ten board-level LEDs LEDR9 - LEDR0
output [7:0]  HEX0;   // board-level 7-segment display
output [7:0]  HEX1;   // board-level 7-segment display
output [7:0]  HEX2;   // board-level 7-segment display
output [7:0]  HEX3;   // board-level 7-segment display
output [7:0]  HEX4;   // board-level 7-segment display
output [7:0]  HEX5;   // board-level 7-segment display


//============================================================================
//  reg/wire declarations
//============================================================================
// More complex implementations will likely declare RGB outputs as regs
// rather than wires
wire clk;
reg [3:0]    red, green, blue;    
reg [15:0] redout,greenout,blueout;
reg [11:0] addr1,addr2,addr3,addr4;
//============================================================================
// Board-LED related circuits
//============================================================================
assign clk=MAX10_CLK1_50;
// Temporary simple logic
// The 10 LEDs will light depending on the position of the adjacent 10 switches
assign LEDR = SW;      // ten LEDs assigned to ten switches

// Temporary simple logic
// This block sets the 7-segment HEX displays
// HEX4 - HEX0 are set to all dark
// HEX5 lights segments based on SW9 - SW2
assign HEX0 = 8'b1111_1111;
assign HEX1 = 8'b1111_1111;
assign HEX2 = 8'b1111_1111;
assign HEX3 = 8'b1111_1111;
assign HEX4 = 8'b1111_1111;
assign HEX5 = ~{SW[9], SW[8], SW[7], SW[6], SW[5], SW[4], SW[3], SW[2]};


//==============================================================
// VGA display related circuits
//==============================================================
			Red_rom_1 rrom1(.clock(clk), .address(addr1), .data_out(red);
			Green_rom_1 grom1(.clock(clk), .address(addr1), .data_out(green);
			Blue_rom_1 brom1(.clock(clk), .address(addr1), .data_out(blue);
			Red_rom_2 rrom2(.clock(clk), .address(addr2), .data_out(red));
			Green_rom_2 grom2(.clock(clk), .address(addr2), .data_out(green));
			Blue_rom_2 brom2(.clock(clk), .address(addr2), .data_out(blue));
			Red_rom_3 rrom3(.clock(clk), .address(addr3), .data_out(red));
			Green_rom_3 grom3(.clock(clk), .address(addr3), .data_out(green));
			Blue_rom_3 brom3(.clock(clk), .address(addr3), .data_out(blue));
			Red_rom_4 rrom4(.clock(clk), .address(addr4), .data_out(red));
			Green_rom_4 grom4(.clock(clk), .address(addr4), .data_out(green));
			Blue_rom_4 brom4(.clock(clk), .address(addr4), .data_out(blue));
always@(*)begin
	for(col=10'd1;col<=10'd64;col=col+10'd1)begin
		for(row=9'd1;col<=9'd64;row=row+9'd1)begin
			addr1 = addr1+1'b1;
		end
	end
	for(col=10'd65;col<=10'd128;col=col+10'd1)begin
		for(row=9'd1;col<=9'd64;row=row+9'd1)begin
			addr2 = addr2+1'b1;
		end
	end
	for(col=10'd1;col<=10'd64;col=col+10'd1)begin
		for(row=9'd65;col<=9'd128;row=row+9'd1)begin
			addr3 = addr3+1'b1;
		end
	end
	for(col=10'd65;col<=10'd128;col=col+10'd1)begin
		for(row=9'd65;col<=9'd128;row=row+9'd1)begin
			addr4 = addr4+1'b1;
		end
	end
end
// Temporary simple logic
// Full intensity is SW[0] is '1'. Blank otherwise
always@(*)begin
  	   casex(SW)
		  xx_xxx1_0000:begin                        //display in grayscale
		  end
		  xx_xx10_0000:begin                        //display blue off
		      
		  end
		  xx_x100_0000:begin                        //display green off
		  end
		  xx_1000_0000:begin                        //display red off
		  end
		  01_0000_0000:begin                        //display zoom 2x
		  end
		  10_0000_0000:begin                        //display zoom 3x
		  end
		  11_0000_0000:begin                        //display zoom 4x
		  end
		endcase  
end

endmodule
